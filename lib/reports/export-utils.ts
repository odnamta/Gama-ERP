// Export Utility Functions for Reports

import * as XLSX from 'xlsx'
import { DateRange } from '@/types/reports'

export interface ExportColumn {
  key: string
  header: string
  format?: 'currency' | 'percentage' | 'number' | 'date' | 'text'
}

export interface ExportMetadata {
  generatedAt: Date
  generatedBy: string
  reportTitle: string
  period?: DateRange
}

export interface ExportOptions {
  reportTitle: string
  columns: ExportColumn[]
  data: Record<string, unknown>[]
  metadata: ExportMetadata
  summary?: { label: string; value: string | number }[]
}

/**
 * Format value based on column format type
 */
export function formatExportValue(value: unknown, format?: ExportColumn['format']): string | number {
  if (value === null || value === undefined) return ''
  
  switch (format) {
    case 'currency':
      return typeof value === 'number' ? value : parseFloat(String(value)) || 0
    case 'percentage':
      return typeof value === 'number' ? `${value.toFixed(1)}%` : String(value)
    case 'number':
      return typeof value === 'number' ? value : parseFloat(String(value)) || 0
    case 'date':
      if (value instanceof Date) {
        return value.toLocaleDateString('id-ID')
      }
      return String(value)
    default:
      return String(value)
  }
}

/**
 * Format data for export
 */
export function formatExportData(
  data: Record<string, unknown>[],
  columns: ExportColumn[]
): Record<string, string | number>[] {
  return data.map(row => {
    const formattedRow: Record<string, string | number> = {}
    for (const col of columns) {
      formattedRow[col.header] = formatExportValue(row[col.key], col.format)
    }
    return formattedRow
  })
}

/**
 * Generate Excel report
 */
export function generateExcelReport(options: ExportOptions): Blob {
  const { reportTitle, columns, data, metadata, summary } = options
  
  const workbook = XLSX.utils.book_new()
  
  // Create header rows with metadata
  const headerRows: (string | number)[][] = [
    [reportTitle],
    [`Generated: ${metadata.generatedAt.toLocaleString('id-ID')}`],
    [`Generated by: ${metadata.generatedBy}`],
  ]
  
  if (metadata.period) {
    headerRows.push([
      `Period: ${metadata.period.startDate.toLocaleDateString('id-ID')} - ${metadata.period.endDate.toLocaleDateString('id-ID')}`
    ])
  }
  
  headerRows.push([]) // Empty row
  
  // Add summary if provided
  if (summary && summary.length > 0) {
    headerRows.push(['Summary'])
    for (const item of summary) {
      headerRows.push([item.label, String(item.value)])
    }
    headerRows.push([]) // Empty row
  }
  
  // Format data
  const formattedData = formatExportData(data, columns)
  
  // Create worksheet
  const worksheet = XLSX.utils.aoa_to_sheet(headerRows)
  
  // Add data table
  XLSX.utils.sheet_add_json(worksheet, formattedData, {
    origin: `A${headerRows.length + 1}`,
    header: columns.map(c => c.header),
  })
  
  // Add worksheet to workbook
  XLSX.utils.book_append_sheet(workbook, worksheet, 'Report')
  
  // Generate blob
  const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' })
  return new Blob([excelBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' })
}

/**
 * Download file helper
 */
export function downloadFile(blob: Blob, filename: string): void {
  const url = URL.createObjectURL(blob)
  const link = document.createElement('a')
  link.href = url
  link.download = filename
  document.body.appendChild(link)
  link.click()
  document.body.removeChild(link)
  URL.revokeObjectURL(url)
}

/**
 * Generate and download Excel report
 */
export function downloadExcelReport(options: ExportOptions, filename?: string): void {
  const blob = generateExcelReport(options)
  const defaultFilename = `${options.reportTitle.toLowerCase().replace(/\s+/g, '-')}-${new Date().toISOString().split('T')[0]}.xlsx`
  downloadFile(blob, filename || defaultFilename)
}

/**
 * Check if export metadata is valid
 */
export function validateExportMetadata(metadata: ExportMetadata): boolean {
  return !!(
    metadata.generatedAt instanceof Date &&
    metadata.generatedBy &&
    metadata.reportTitle
  )
}
