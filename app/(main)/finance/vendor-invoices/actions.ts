'use server'

/**
 * Vendor Invoice Server Actions
 * CRUD operations for accounts payable (vendor invoices)
 * 
 * Feature: accounts-payable
 */

import { createClient } from '@/lib/supabase/server'
import { revalidatePath } from 'next/cache'
import type {
  VendorInvoiceWithRelations,
  VendorInvoiceFormData,
  VendorInvoiceFilterState,
  VendorInvoiceStatus,
} from '@/types/vendor-invoices'
import {
  validateVendorInvoiceInput,
  calculateDefaultDueDate,
  canViewVendorInvoices,
  canEditVendorInvoices,
  canDeleteVendorInvoices,
  calculateAgingBucket,
} from '@/lib/vendor-invoice-utils'

/**
 * Get current user profile with role
 */
async function getCurrentUserProfile() {
  const supabase = await createClient()
  const { data: { user } } = await supabase.auth.getUser()
  
  if (!user) return null
  
  const { data: profile } = await supabase
    .from('user_profiles')
    .select('id, role, full_name')
    .eq('user_id', user.id)
    .single()
  
  return profile
}

/**
 * Create a new vendor invoice
 * 
 * **Feature: accounts-payable, Property 4: Invoice Creation Data Integrity**
 * **Validates: Requirements 1.1, 1.2, 1.4, 1.5, 1.6, 1.7**
 */
export async function createVendorInvoice(
  data: VendorInvoiceFormData
): Promise<{ id?: string; error?: string }> {
  const supabase = await createClient()
  
  // Get current user
  const profile = await getCurrentUserProfile()
  if (!profile) {
    return { error: 'User not authenticated' }
  }
  
  // Check permission
  if (!canEditVendorInvoices(profile.role)) {
    return { error: 'You do not have permission to create vendor invoices' }
  }
  
  // Validate input
  const validation = validateVendorInvoiceInput({
    vendor_id: data.vendor_id,
    invoice_number: data.invoice_number,
    invoice_date: data.invoice_date,
    subtotal: data.subtotal,
    tax_amount: data.tax_amount,
  })
  
  if (!validation.isValid) {
    return { error: validation.errors.join(', ') }
  }
  
  // Calculate total amount
  const totalAmount = data.subtotal + (data.tax_amount || 0)
  
  // Calculate due date if not provided (default 30 days)
  const dueDate = data.due_date || calculateDefaultDueDate(data.invoice_date)
  
  // Create vendor invoice (internal_ref is auto-generated by trigger)
  const { data: invoice, error } = await supabase
    .from('vendor_invoices')
    .insert({
      vendor_id: data.vendor_id,
      invoice_number: data.invoice_number,
      invoice_date: data.invoice_date,
      received_date: data.received_date || new Date().toISOString().split('T')[0],
      due_date: dueDate,
      description: data.description || null,
      subtotal: data.subtotal,
      tax_amount: data.tax_amount || 0,
      total_amount: totalAmount,
      expense_category: data.expense_category || null,
      jo_id: data.jo_id || null,
      pjo_id: data.pjo_id || null,
      bkk_id: data.bkk_id || null,
      document_url: data.document_url || null,
      notes: data.notes || null,
      status: 'received',
      created_by: profile.id,
    })
    .select('id')
    .single()
  
  if (error) {
    return { error: error.message }
  }
  
  // Link BKK if provided (bidirectional linking)
  if (data.bkk_id) {
    const { error: bkkError } = await supabase
      .from('bukti_kas_keluar')
      .update({ vendor_invoice_id: invoice.id })
      .eq('id', data.bkk_id)
    
    if (bkkError) {
    }
  }
  
  // Revalidate paths
  revalidatePath('/finance/vendor-invoices')
  if (data.jo_id) {
    revalidatePath(`/job-orders/${data.jo_id}`)
  }
  
  return { id: invoice.id }
}


/**
 * Update an existing vendor invoice
 * 
 * **Validates: Requirements 1.1**
 */
export async function updateVendorInvoice(
  id: string,
  data: Partial<VendorInvoiceFormData>
): Promise<{ error?: string }> {
  const supabase = await createClient()
  
  // Get current user
  const profile = await getCurrentUserProfile()
  if (!profile) {
    return { error: 'User not authenticated' }
  }
  
  // Check permission
  if (!canEditVendorInvoices(profile.role)) {
    return { error: 'You do not have permission to edit vendor invoices' }
  }
  
  // Get current invoice
  const { data: currentInvoice, error: fetchError } = await supabase
    .from('vendor_invoices')
    .select('status, bkk_id')
    .eq('id', id)
    .single()
  
  if (fetchError || !currentInvoice) {
    return { error: 'Vendor invoice not found' }
  }
  
  // Can only edit invoices in certain statuses
  if (!currentInvoice.status || !['received', 'disputed'].includes(currentInvoice.status)) {
    return { error: 'Cannot edit invoice in current status' }
  }
  
  // Build update object
  const updateData: Record<string, unknown> = {
    updated_at: new Date().toISOString(),
  }
  
  if (data.vendor_id !== undefined) updateData.vendor_id = data.vendor_id
  if (data.invoice_number !== undefined) updateData.invoice_number = data.invoice_number
  if (data.invoice_date !== undefined) updateData.invoice_date = data.invoice_date
  if (data.received_date !== undefined) updateData.received_date = data.received_date
  if (data.due_date !== undefined) updateData.due_date = data.due_date
  if (data.description !== undefined) updateData.description = data.description
  if (data.expense_category !== undefined) updateData.expense_category = data.expense_category
  if (data.jo_id !== undefined) updateData.jo_id = data.jo_id
  if (data.pjo_id !== undefined) updateData.pjo_id = data.pjo_id
  if (data.document_url !== undefined) updateData.document_url = data.document_url
  if (data.notes !== undefined) updateData.notes = data.notes
  
  // Recalculate total if amounts changed
  if (data.subtotal !== undefined || data.tax_amount !== undefined) {
    const { data: invoice } = await supabase
      .from('vendor_invoices')
      .select('subtotal, tax_amount')
      .eq('id', id)
      .single()
    
    const newSubtotal = data.subtotal ?? invoice?.subtotal ?? 0
    const newTaxAmount = data.tax_amount ?? invoice?.tax_amount ?? 0
    
    updateData.subtotal = newSubtotal
    updateData.tax_amount = newTaxAmount
    updateData.total_amount = newSubtotal + newTaxAmount
  }
  
  // Handle BKK linking changes
  if (data.bkk_id !== undefined && data.bkk_id !== currentInvoice.bkk_id) {
    // Unlink old BKK
    if (currentInvoice.bkk_id) {
      await supabase
        .from('bukti_kas_keluar')
        .update({ vendor_invoice_id: null })
        .eq('id', currentInvoice.bkk_id)
    }
    
    // Link new BKK
    if (data.bkk_id) {
      await supabase
        .from('bukti_kas_keluar')
        .update({ vendor_invoice_id: id })
        .eq('id', data.bkk_id)
    }
    
    updateData.bkk_id = data.bkk_id
  }
  
  // Update invoice
  const { error: updateError } = await supabase
    .from('vendor_invoices')
    .update(updateData)
    .eq('id', id)
  
  if (updateError) {
    return { error: updateError.message }
  }
  
  revalidatePath('/finance/vendor-invoices')
  revalidatePath(`/finance/vendor-invoices/${id}`)
  
  return {}
}

/**
 * Delete a vendor invoice (only if status is 'received')
 * 
 * **Validates: Requirements 1.1**
 */
export async function deleteVendorInvoice(id: string): Promise<{ error?: string }> {
  const supabase = await createClient()
  
  // Get current user
  const profile = await getCurrentUserProfile()
  if (!profile) {
    return { error: 'User not authenticated' }
  }
  
  // Check permission
  if (!canDeleteVendorInvoices(profile.role)) {
    return { error: 'You do not have permission to delete vendor invoices' }
  }
  
  // Get current invoice
  const { data: invoice, error: fetchError } = await supabase
    .from('vendor_invoices')
    .select('status, bkk_id')
    .eq('id', id)
    .single()
  
  if (fetchError || !invoice) {
    return { error: 'Vendor invoice not found' }
  }
  
  // Can only delete invoices in 'received' status
  if (invoice.status !== 'received') {
    return { error: 'Can only delete invoices in received status' }
  }
  
  // Unlink BKK if linked
  if (invoice.bkk_id) {
    await supabase
      .from('bukti_kas_keluar')
      .update({ vendor_invoice_id: null })
      .eq('id', invoice.bkk_id)
  }
  
  // Delete invoice
  const { error: deleteError } = await supabase
    .from('vendor_invoices')
    .delete()
    .eq('id', id)
  
  if (deleteError) {
    return { error: deleteError.message }
  }
  
  revalidatePath('/finance/vendor-invoices')
  
  return {}
}


/**
 * Get vendor invoices with filters
 * 
 * **Feature: accounts-payable, Property 6: Invoice List Ordering**
 * **Feature: accounts-payable, Property 7: Filter Results Correctness**
 * **Validates: Requirements 3.1, 3.3, 3.4, 3.5, 11.5, 12.5**
 */
export async function getVendorInvoices(
  filters?: Partial<VendorInvoiceFilterState>
): Promise<VendorInvoiceWithRelations[]> {
  const supabase = await createClient()
  
  // Get current user
  const profile = await getCurrentUserProfile()
  if (!profile) {
    return []
  }
  
  // Check permission
  if (!canViewVendorInvoices(profile.role)) {
    return []
  }
  
  let query = supabase
    .from('vendor_invoices')
    .select(`
      *,
      vendor:vendors (
        id,
        vendor_name,
        vendor_code,
        bank_name,
        bank_account,
        tax_id
      ),
      job_order:job_orders (
        id,
        jo_number
      ),
      pjo:proforma_job_orders (
        id,
        pjo_number
      ),
      bkk:bukti_kas_keluar (
        id,
        bkk_number,
        amount_spent,
        amount_requested
      ),
      verifier:user_profiles!vendor_invoices_verified_by_fkey (
        id,
        full_name
      ),
      approver:user_profiles!vendor_invoices_approved_by_fkey (
        id,
        full_name
      ),
      creator:user_profiles!vendor_invoices_created_by_fkey (
        id,
        full_name
      )
    `)
    .order('due_date', { ascending: true, nullsFirst: false })
  
  // Apply filters
  if (filters?.status && filters.status !== 'all') {
    query = query.eq('status', filters.status)
  }
  
  if (filters?.vendorId && filters.vendorId !== 'all') {
    query = query.eq('vendor_id', filters.vendorId)
  }
  
  if (filters?.joId && filters.joId !== 'all') {
    query = query.eq('jo_id', filters.joId)
  }
  
  if (filters?.pjoId && filters.pjoId !== 'all') {
    query = query.eq('pjo_id', filters.pjoId)
  }
  
  if (filters?.dateFrom) {
    query = query.gte('invoice_date', filters.dateFrom)
  }
  
  if (filters?.dateTo) {
    query = query.lte('invoice_date', filters.dateTo)
  }
  
  if (filters?.search) {
    const searchTerm = `%${filters.search}%`
    query = query.or(`invoice_number.ilike.${searchTerm},internal_ref.ilike.${searchTerm},description.ilike.${searchTerm}`)
  }
  
  const { data, error } = await query
  
  if (error) {
    return []
  }
  
  // Filter by aging bucket if specified (done in memory since it's calculated)
  let results = data as VendorInvoiceWithRelations[]
  
  if (filters?.agingBucket && filters.agingBucket !== 'all') {
    results = results.filter(invoice => {
      if (invoice.status === 'paid' || invoice.status === 'cancelled') {
        return filters.agingBucket === 'current'
      }
      return calculateAgingBucket(invoice.due_date) === filters.agingBucket
    })
  }
  
  return results
}

/**
 * Get a single vendor invoice by ID
 * 
 * **Validates: Requirements 2.3, 5.5, 7.6, 10.3**
 */
export async function getVendorInvoiceById(
  id: string
): Promise<VendorInvoiceWithRelations | null> {
  const supabase = await createClient()
  
  // Get current user
  const profile = await getCurrentUserProfile()
  if (!profile) {
    return null
  }
  
  // Check permission
  if (!canViewVendorInvoices(profile.role)) {
    return null
  }
  
  const { data, error } = await supabase
    .from('vendor_invoices')
    .select(`
      *,
      vendor:vendors (
        id,
        vendor_name,
        vendor_code,
        bank_name,
        bank_account,
        tax_id
      ),
      job_order:job_orders (
        id,
        jo_number
      ),
      pjo:proforma_job_orders (
        id,
        pjo_number
      ),
      bkk:bukti_kas_keluar (
        id,
        bkk_number,
        amount_spent,
        amount_requested
      ),
      verifier:user_profiles!vendor_invoices_verified_by_fkey (
        id,
        full_name
      ),
      approver:user_profiles!vendor_invoices_approved_by_fkey (
        id,
        full_name
      ),
      creator:user_profiles!vendor_invoices_created_by_fkey (
        id,
        full_name
      )
    `)
    .eq('id', id)
    .single()
  
  if (error) {
    return null
  }
  
  return data as VendorInvoiceWithRelations
}

/**
 * Get matching BKKs for a vendor and JO/PJO
 * 
 * **Feature: accounts-payable, Property 16: Matching BKK Query**
 * **Validates: Requirements 10.1**
 */
export async function getMatchingBKKs(
  vendorId: string,
  joId?: string,
  pjoId?: string
): Promise<{ id: string; bkk_number: string; amount_spent: number | null; amount_requested: number; purpose: string }[]> {
  const supabase = await createClient()
  
  let query = supabase
    .from('bukti_kas_keluar')
    .select('id, bkk_number, amount_spent, amount_requested, purpose')
    .eq('vendor_id', vendorId)
    .in('status', ['released', 'settled'])
    .is('vendor_invoice_id', null) // Only unlinked BKKs
  
  if (joId) {
    query = query.eq('jo_id', joId)
  }
  
  const { data, error } = await query.order('created_at', { ascending: false })
  
  if (error) {
    return []
  }
  
  return data || []
}

/**
 * Get vendors for dropdown (active vendors only)
 */
export async function getVendorsForDropdown(): Promise<{ id: string; vendor_name: string; vendor_code: string }[]> {
  const supabase = await createClient()
  
  const { data, error } = await supabase
    .from('vendors')
    .select('id, vendor_name, vendor_code')
    .eq('is_active', true)
    .order('vendor_name')
  
  if (error) {
    return []
  }
  
  return data || []
}

/**
 * Get job orders for dropdown
 */
export async function getJobOrdersForDropdown(): Promise<{ id: string; jo_number: string; description: string | null }[]> {
  const supabase = await createClient()
  
  const { data, error } = await supabase
    .from('job_orders')
    .select('id, jo_number, description')
    .in('status', ['active', 'completed', 'invoiced'])
    .order('created_at', { ascending: false })
    .limit(100)
  
  if (error) {
    return []
  }
  
  return data || []
}

/**
 * Get PJOs for dropdown
 */
export async function getPJOsForDropdown(): Promise<{ id: string; pjo_number: string; description: string | null }[]> {
  const supabase = await createClient()
  
  const { data, error } = await supabase
    .from('proforma_job_orders')
    .select('id, pjo_number, description')
    .eq('status', 'approved')
    .order('created_at', { ascending: false })
    .limit(100)
  
  if (error) {
    return []
  }
  
  return data || []
}


// =====================================================
// Task 5: Verification and Approval Actions
// =====================================================

import type { VerificationResult } from '@/types/vendor-invoices'
import {
  calculateVariance,
  isWithinTolerance,
  canApproveVendorInvoices,
} from '@/lib/vendor-invoice-utils'

/**
 * Verify vendor invoice (3-way match with BKK)
 * 
 * **Feature: accounts-payable, Property 12: Verification Status Determination**
 * **Feature: accounts-payable, Property 13: Verification Metadata Recording**
 * **Validates: Requirements 5.2, 5.3, 5.4, 10.1**
 */
export async function verifyVendorInvoice(
  id: string,
  notes?: string
): Promise<{ result?: VerificationResult; error?: string }> {
  const supabase = await createClient()
  
  // Get current user
  const profile = await getCurrentUserProfile()
  if (!profile) {
    return { error: 'User not authenticated' }
  }
  
  // Check permission
  if (!canEditVendorInvoices(profile.role)) {
    return { error: 'You do not have permission to verify vendor invoices' }
  }
  
  // Get invoice with BKK
  const { data: invoice, error: fetchError } = await supabase
    .from('vendor_invoices')
    .select(`
      id, status, total_amount, bkk_id,
      bkk:bukti_kas_keluar (id, amount_spent, amount_requested)
    `)
    .eq('id', id)
    .single()
  
  if (fetchError || !invoice) {
    return { error: 'Vendor invoice not found' }
  }
  
  // Must be in 'received' status to verify
  if (invoice.status !== 'received') {
    return { error: 'Can only verify invoices in received status' }
  }
  
  // Must have linked BKK for 3-way match
  if (!invoice.bkk_id || !invoice.bkk) {
    return { error: 'Cannot verify invoice without linked BKK' }
  }
  
  // Calculate variance
  const bkkAmount = invoice.bkk.amount_spent ?? invoice.bkk.amount_requested
  const varianceResult = calculateVariance(bkkAmount, invoice.total_amount)
  
  // Determine new status based on variance
  const newStatus = varianceResult.withinTolerance ? 'verified' : 'disputed'
  
  // Update invoice
  const { error: updateError } = await supabase
    .from('vendor_invoices')
    .update({
      status: newStatus,
      verified_at: new Date().toISOString(),
      verified_by: profile.id,
      verification_notes: notes || null,
      updated_at: new Date().toISOString(),
    })
    .eq('id', id)
  
  if (updateError) {
    return { error: updateError.message }
  }
  
  revalidatePath('/finance/vendor-invoices')
  revalidatePath(`/finance/vendor-invoices/${id}`)
  
  return {
    result: {
      matched: varianceResult.withinTolerance,
      bkkAmount,
      invoiceAmount: invoice.total_amount,
      variance: varianceResult.variance,
      variancePercent: varianceResult.variancePercent,
    },
  }
}


/**
 * Approve vendor invoice for payment
 * 
 * **Feature: accounts-payable, Property 14: Approval Status Transition**
 * **Validates: Requirements 6.1, 6.2, 6.3**
 */
export async function approveVendorInvoice(
  id: string
): Promise<{ error?: string }> {
  const supabase = await createClient()
  
  // Get current user
  const profile = await getCurrentUserProfile()
  if (!profile) {
    return { error: 'User not authenticated' }
  }
  
  // Check permission
  if (!canApproveVendorInvoices(profile.role)) {
    return { error: 'You do not have permission to approve vendor invoices' }
  }
  
  // Get current invoice
  const { data: invoice, error: fetchError } = await supabase
    .from('vendor_invoices')
    .select('status')
    .eq('id', id)
    .single()
  
  if (fetchError || !invoice) {
    return { error: 'Vendor invoice not found' }
  }
  
  // Can only approve from 'verified' status
  if (invoice.status !== 'verified') {
    return { error: 'Cannot approve invoice that is not verified' }
  }
  
  // Update invoice
  const { error: updateError } = await supabase
    .from('vendor_invoices')
    .update({
      status: 'approved',
      approved_at: new Date().toISOString(),
      approved_by: profile.id,
      updated_at: new Date().toISOString(),
    })
    .eq('id', id)
  
  if (updateError) {
    return { error: updateError.message }
  }
  
  revalidatePath('/finance/vendor-invoices')
  revalidatePath(`/finance/vendor-invoices/${id}`)
  
  return {}
}

/**
 * Flag vendor invoice as disputed
 * 
 * **Validates: Requirements 5.3**
 */
export async function disputeVendorInvoice(
  id: string,
  reason: string
): Promise<{ error?: string }> {
  const supabase = await createClient()
  
  // Get current user
  const profile = await getCurrentUserProfile()
  if (!profile) {
    return { error: 'User not authenticated' }
  }
  
  // Check permission
  if (!canEditVendorInvoices(profile.role)) {
    return { error: 'You do not have permission to dispute vendor invoices' }
  }
  
  if (!reason || reason.trim().length === 0) {
    return { error: 'Dispute reason is required' }
  }
  
  // Get current invoice
  const { data: invoice, error: fetchError } = await supabase
    .from('vendor_invoices')
    .select('status')
    .eq('id', id)
    .single()
  
  if (fetchError || !invoice) {
    return { error: 'Vendor invoice not found' }
  }
  
  // Can dispute from 'received' or 'verified' status
  if (!invoice.status || !['received', 'verified'].includes(invoice.status)) {
    return { error: 'Cannot dispute invoice in current status' }
  }
  
  // Update invoice
  const { error: updateError } = await supabase
    .from('vendor_invoices')
    .update({
      status: 'disputed',
      verification_notes: reason,
      verified_at: new Date().toISOString(),
      verified_by: profile.id,
      updated_at: new Date().toISOString(),
    })
    .eq('id', id)
  
  if (updateError) {
    return { error: updateError.message }
  }
  
  revalidatePath('/finance/vendor-invoices')
  revalidatePath(`/finance/vendor-invoices/${id}`)
  
  return {}
}


// =====================================================
// Task 6: Payment and Summary Actions
// =====================================================

import type {
  VendorPaymentFormData,
  VendorPaymentWithRecorder,
  APSummary,
  APSummaryWithAging,
} from '@/types/vendor-invoices'
import {
  validatePaymentAmount,
  isValidPaymentMethod,
  determineVendorInvoiceStatus,
} from '@/lib/vendor-invoice-utils'

/**
 * Record payment against vendor invoice
 * 
 * **Feature: accounts-payable, Property 15: Payment Recording and Status Update**
 * **Validates: Requirements 7.1, 7.2, 7.3, 7.4**
 */
export async function recordVendorPayment(
  data: VendorPaymentFormData
): Promise<{ id?: string; error?: string }> {
  const supabase = await createClient()
  
  // Get current user
  const profile = await getCurrentUserProfile()
  if (!profile) {
    return { error: 'User not authenticated' }
  }
  
  // Check permission
  if (!canEditVendorInvoices(profile.role)) {
    return { error: 'You do not have permission to record payments' }
  }
  
  // Validate payment amount
  const amountValidation = validatePaymentAmount(data.amount)
  if (!amountValidation.isValid) {
    return { error: amountValidation.error }
  }
  
  // Validate payment method
  if (!isValidPaymentMethod(data.payment_method)) {
    return { error: 'Invalid payment method selected' }
  }
  
  // Get current invoice
  const { data: invoice, error: fetchError } = await supabase
    .from('vendor_invoices')
    .select('id, status, total_amount, amount_paid')
    .eq('id', data.vendor_invoice_id)
    .single()
  
  if (fetchError || !invoice) {
    return { error: 'Vendor invoice not found' }
  }
  
  // Cannot record payment for cancelled invoices
  if (invoice.status === 'cancelled') {
    return { error: 'Cannot record payment for cancelled invoice' }
  }
  
  // Create payment record
  const { data: payment, error: paymentError } = await supabase
    .from('vendor_payments')
    .insert({
      vendor_invoice_id: data.vendor_invoice_id,
      payment_date: data.payment_date,
      amount: data.amount,
      payment_method: data.payment_method,
      reference_number: data.reference_number || null,
      bank_name: data.bank_name || null,
      bank_account: data.bank_account || null,
      proof_url: data.proof_url || null,
      notes: data.notes || null,
      created_by: profile.id,
    })
    .select('id')
    .single()
  
  if (paymentError) {
    return { error: paymentError.message }
  }
  
  // Calculate new amount_paid and determine new status
  const newAmountPaid = (invoice.amount_paid ?? 0) + data.amount
  const newStatus = determineVendorInvoiceStatus(
    invoice.total_amount,
    newAmountPaid,
    (invoice.status as VendorInvoiceStatus) ?? 'received'
  )
  
  // Update invoice
  const { error: updateError } = await supabase
    .from('vendor_invoices')
    .update({
      amount_paid: newAmountPaid,
      status: newStatus,
      updated_at: new Date().toISOString(),
    })
    .eq('id', data.vendor_invoice_id)
  
  if (updateError) {
    // Payment was recorded but invoice update failed - log but don't fail
  }
  
  revalidatePath('/finance/vendor-invoices')
  revalidatePath(`/finance/vendor-invoices/${data.vendor_invoice_id}`)
  
  return { id: payment.id }
}

/**
 * Get payments for a vendor invoice
 * 
 * **Validates: Requirements 7.6**
 */
export async function getVendorPayments(
  vendorInvoiceId: string
): Promise<VendorPaymentWithRecorder[]> {
  const supabase = await createClient()
  
  // Get current user
  const profile = await getCurrentUserProfile()
  if (!profile) {
    return []
  }
  
  // Check permission
  if (!canViewVendorInvoices(profile.role)) {
    return []
  }
  
  const { data, error } = await supabase
    .from('vendor_payments')
    .select(`
      *,
      recorder:user_profiles!vendor_payments_created_by_fkey (
        id,
        full_name
      )
    `)
    .eq('vendor_invoice_id', vendorInvoiceId)
    .order('payment_date', { ascending: false })
  
  if (error) {
    return []
  }
  
  return data as VendorPaymentWithRecorder[]
}

/**
 * Delete a vendor payment
 * 
 * **Validates: Requirements 7.6**
 */
export async function deleteVendorPayment(
  paymentId: string
): Promise<{ error?: string }> {
  const supabase = await createClient()
  
  // Get current user
  const profile = await getCurrentUserProfile()
  if (!profile) {
    return { error: 'User not authenticated' }
  }
  
  // Check permission
  if (!canDeleteVendorInvoices(profile.role)) {
    return { error: 'You do not have permission to delete payments' }
  }
  
  // Get payment details
  const { data: payment, error: fetchError } = await supabase
    .from('vendor_payments')
    .select('id, vendor_invoice_id, amount')
    .eq('id', paymentId)
    .single()
  
  if (fetchError || !payment) {
    return { error: 'Payment not found' }
  }
  
  // Get current invoice
  const { data: invoice, error: invoiceError } = await supabase
    .from('vendor_invoices')
    .select('id, status, total_amount, amount_paid')
    .eq('id', payment.vendor_invoice_id)
    .single()
  
  if (invoiceError || !invoice) {
    return { error: 'Vendor invoice not found' }
  }
  
  // Delete payment
  const { error: deleteError } = await supabase
    .from('vendor_payments')
    .delete()
    .eq('id', paymentId)
  
  if (deleteError) {
    return { error: deleteError.message }
  }
  
  // Recalculate invoice amount_paid and status
  const newAmountPaid = Math.max(0, (invoice.amount_paid ?? 0) - payment.amount)
  const newStatus = determineVendorInvoiceStatus(
    invoice.total_amount,
    newAmountPaid,
    (invoice.status as VendorInvoiceStatus) ?? 'received'
  )
  
  // Update invoice
  await supabase
    .from('vendor_invoices')
    .update({
      amount_paid: newAmountPaid,
      status: newStatus,
      updated_at: new Date().toISOString(),
    })
    .eq('id', payment.vendor_invoice_id)
  
  revalidatePath('/finance/vendor-invoices')
  revalidatePath(`/finance/vendor-invoices/${payment.vendor_invoice_id}`)
  
  return {}
}

/**
 * Get AP summary statistics
 * 
 * **Feature: accounts-payable, Property 10: AP Summary Calculation**
 * **Validates: Requirements 4.1, 4.2, 4.3, 4.4, 4.5**
 */
export async function getAPSummary(): Promise<APSummary> {
  const supabase = await createClient()
  
  // Get current user
  const profile = await getCurrentUserProfile()
  if (!profile) {
    return {
      totalUnpaid: 0,
      dueToday: 0,
      overdue: 0,
      paidMTD: 0,
      pendingVerification: 0,
    }
  }
  
  // Check permission
  if (!canViewVendorInvoices(profile.role)) {
    return {
      totalUnpaid: 0,
      dueToday: 0,
      overdue: 0,
      paidMTD: 0,
      pendingVerification: 0,
    }
  }
  
  const today = new Date().toISOString().split('T')[0]
  const monthStart = new Date()
  monthStart.setDate(1)
  const monthStartStr = monthStart.toISOString().split('T')[0]
  
  // Get all unpaid invoices
  const { data: invoices, error: invoicesError } = await supabase
    .from('vendor_invoices')
    .select('id, status, due_date, amount_due, total_amount, amount_paid')
    .not('status', 'in', '("paid","cancelled")')
  
  if (invoicesError) {
    return {
      totalUnpaid: 0,
      dueToday: 0,
      overdue: 0,
      paidMTD: 0,
      pendingVerification: 0,
    }
  }
  
  // Get payments this month
  const { data: payments, error: paymentsError } = await supabase
    .from('vendor_payments')
    .select('amount')
    .gte('payment_date', monthStartStr)
    .lte('payment_date', today)
  
  if (paymentsError) {
  }
  
  // Calculate summary
  let totalUnpaid = 0
  let dueToday = 0
  let overdue = 0
  let pendingVerification = 0
  
  for (const invoice of invoices || []) {
    const amountDue = invoice.total_amount - (invoice.amount_paid ?? 0)
    totalUnpaid += amountDue
    
    if (invoice.status === 'received') {
      pendingVerification++
    }
    
    if (invoice.due_date) {
      if (invoice.due_date === today) {
        dueToday += amountDue
      } else if (invoice.due_date < today) {
        overdue += amountDue
      }
    }
  }
  
  const paidMTD = (payments || []).reduce((sum, p) => sum + Number(p.amount), 0)
  
  return {
    totalUnpaid,
    dueToday,
    overdue,
    paidMTD,
    pendingVerification,
  }
}

/**
 * Get AP summary with aging buckets
 * 
 * **Feature: accounts-payable, Property 20: Aging Bucket Calculation**
 * **Validates: Requirements 12.3**
 */
export async function getAPSummaryWithAging(): Promise<APSummaryWithAging> {
  const supabase = await createClient()
  
  // Get base summary
  const summary = await getAPSummary()
  
  // Get current user
  const profile = await getCurrentUserProfile()
  if (!profile || !canViewVendorInvoices(profile.role)) {
    return {
      ...summary,
      aging: {
        current: 0,
        days1to30: 0,
        days31to60: 0,
        days61to90: 0,
        days90plus: 0,
      },
    }
  }
  
  const today = new Date()
  today.setHours(0, 0, 0, 0)
  
  // Get all unpaid invoices with due dates
  const { data: invoices, error } = await supabase
    .from('vendor_invoices')
    .select('due_date, total_amount, amount_paid')
    .not('status', 'in', '("paid","cancelled")')
  
  if (error) {
    return {
      ...summary,
      aging: {
        current: 0,
        days1to30: 0,
        days31to60: 0,
        days61to90: 0,
        days90plus: 0,
      },
    }
  }
  
  // Calculate aging buckets
  const aging = {
    current: 0,
    days1to30: 0,
    days31to60: 0,
    days61to90: 0,
    days90plus: 0,
  }
  
  for (const invoice of invoices || []) {
    const amountDue = invoice.total_amount - (invoice.amount_paid ?? 0)
    
    if (!invoice.due_date) {
      aging.current += amountDue
      continue
    }
    
    const dueDate = new Date(invoice.due_date)
    dueDate.setHours(0, 0, 0, 0)
    const diffTime = today.getTime() - dueDate.getTime()
    const daysOverdue = Math.floor(diffTime / (1000 * 60 * 60 * 24))
    
    if (daysOverdue <= 0) {
      aging.current += amountDue
    } else if (daysOverdue <= 30) {
      aging.days1to30 += amountDue
    } else if (daysOverdue <= 60) {
      aging.days31to60 += amountDue
    } else if (daysOverdue <= 90) {
      aging.days61to90 += amountDue
    } else {
      aging.days90plus += amountDue
    }
  }
  
  return {
    ...summary,
    aging,
  }
}


// =====================================================
// Task 7: PJO Conversion Integration
// =====================================================

/**
 * Update vendor invoice JO reference when PJO is converted to JO
 * 
 * **Feature: accounts-payable, Property 19: PJO to JO Conversion Linkage**
 * **Validates: Requirements 11.3**
 */
export async function updateVendorInvoiceJOReference(
  pjoId: string,
  joId: string
): Promise<{ error?: string; updatedCount?: number }> {
  const supabase = await createClient()
  
  // Get current user
  const profile = await getCurrentUserProfile()
  if (!profile) {
    return { error: 'User not authenticated' }
  }
  
  // Check permission
  if (!canEditVendorInvoices(profile.role)) {
    return { error: 'You do not have permission to update vendor invoices' }
  }
  
  // Update all vendor invoices linked to this PJO
  const { data, error } = await supabase
    .from('vendor_invoices')
    .update({
      jo_id: joId,
      updated_at: new Date().toISOString(),
    })
    .eq('pjo_id', pjoId)
    .select('id')
  
  if (error) {
    return { error: error.message }
  }
  
  revalidatePath('/finance/vendor-invoices')
  
  return { updatedCount: data?.length || 0 }
}
