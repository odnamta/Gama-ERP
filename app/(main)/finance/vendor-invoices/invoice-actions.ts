'use server'

/**
 * Vendor Invoice CRUD + Workflow Actions
 * Split from actions.ts
 */

import { createClient } from '@/lib/supabase/server'
import { revalidatePath } from 'next/cache'
import { sanitizeSearchInput } from '@/lib/utils/sanitize'
import type {
  VendorInvoiceWithRelations,
  VendorInvoiceFormData,
  VendorInvoiceFilterState,
} from '@/types/vendor-invoices'
import {
  validateVendorInvoiceInput,
  calculateDefaultDueDate,
  canViewVendorInvoices,
  canEditVendorInvoices,
  canDeleteVendorInvoices,
  calculateAgingBucket,
  canApproveVendorInvoices,
} from '@/lib/vendor-invoice-utils'
import type { VerificationResult } from '@/types/vendor-invoices'
import {
  calculateVariance,
} from '@/lib/vendor-invoice-utils'

/**
 * Get current user profile with role (private helper)
 */
async function getCurrentUserProfile() {
  const supabase = await createClient()
  const { data: { user } } = await supabase.auth.getUser()

  if (!user) return null

  const { data: profile } = await supabase
    .from('user_profiles')
    .select('id, role, full_name')
    .eq('user_id', user.id)
    .single()

  return profile
}

/**
 * Create a new vendor invoice
 */
export async function createVendorInvoice(
  data: VendorInvoiceFormData
): Promise<{ id?: string; error?: string }> {
  const supabase = await createClient()

  // Get current user
  const profile = await getCurrentUserProfile()
  if (!profile) {
    return { error: 'User not authenticated' }
  }

  // Check permission
  if (!canEditVendorInvoices(profile.role)) {
    return { error: 'You do not have permission to create vendor invoices' }
  }

  // Validate input
  const validation = validateVendorInvoiceInput({
    vendor_id: data.vendor_id,
    invoice_number: data.invoice_number,
    invoice_date: data.invoice_date,
    subtotal: data.subtotal,
    tax_amount: data.tax_amount,
  })

  if (!validation.isValid) {
    return { error: validation.errors.join(', ') }
  }

  // Calculate total amount
  const totalAmount = data.subtotal + (data.tax_amount || 0)

  // Calculate due date if not provided (default 30 days)
  const dueDate = data.due_date || calculateDefaultDueDate(data.invoice_date)

  // Create vendor invoice (internal_ref is auto-generated by trigger)
  const { data: invoice, error } = await supabase
    .from('vendor_invoices')
    .insert({
      vendor_id: data.vendor_id,
      invoice_number: data.invoice_number,
      invoice_date: data.invoice_date,
      received_date: data.received_date || new Date().toISOString().split('T')[0],
      due_date: dueDate,
      description: data.description || null,
      subtotal: data.subtotal,
      tax_amount: data.tax_amount || 0,
      total_amount: totalAmount,
      expense_category: data.expense_category || null,
      jo_id: data.jo_id || null,
      pjo_id: data.pjo_id || null,
      bkk_id: data.bkk_id || null,
      document_url: data.document_url || null,
      notes: data.notes || null,
      status: 'received',
      created_by: profile.id,
    })
    .select('id')
    .single()

  if (error) {
    return { error: error.message }
  }

  // Link BKK if provided (bidirectional linking)
  if (data.bkk_id) {
    const { error: bkkError } = await supabase
      .from('bukti_kas_keluar')
      .update({ vendor_invoice_id: invoice.id })
      .eq('id', data.bkk_id)

    if (bkkError) {
    }
  }

  // Revalidate paths
  revalidatePath('/finance/vendor-invoices')
  if (data.jo_id) {
    revalidatePath(`/job-orders/${data.jo_id}`)
  }

  return { id: invoice.id }
}


/**
 * Update an existing vendor invoice
 */
export async function updateVendorInvoice(
  id: string,
  data: Partial<VendorInvoiceFormData>
): Promise<{ error?: string }> {
  const supabase = await createClient()

  // Get current user
  const profile = await getCurrentUserProfile()
  if (!profile) {
    return { error: 'User not authenticated' }
  }

  // Check permission
  if (!canEditVendorInvoices(profile.role)) {
    return { error: 'You do not have permission to edit vendor invoices' }
  }

  // Get current invoice
  const { data: currentInvoice, error: fetchError } = await supabase
    .from('vendor_invoices')
    .select('status, bkk_id')
    .eq('id', id)
    .single()

  if (fetchError || !currentInvoice) {
    return { error: 'Vendor invoice not found' }
  }

  // Can only edit invoices in certain statuses
  if (!currentInvoice.status || !['received', 'disputed'].includes(currentInvoice.status)) {
    return { error: 'Cannot edit invoice in current status' }
  }

  // Build update object
  const updateData: Record<string, unknown> = {
    updated_at: new Date().toISOString(),
  }

  if (data.vendor_id !== undefined) updateData.vendor_id = data.vendor_id
  if (data.invoice_number !== undefined) updateData.invoice_number = data.invoice_number
  if (data.invoice_date !== undefined) updateData.invoice_date = data.invoice_date
  if (data.received_date !== undefined) updateData.received_date = data.received_date
  if (data.due_date !== undefined) updateData.due_date = data.due_date
  if (data.description !== undefined) updateData.description = data.description
  if (data.expense_category !== undefined) updateData.expense_category = data.expense_category
  if (data.jo_id !== undefined) updateData.jo_id = data.jo_id
  if (data.pjo_id !== undefined) updateData.pjo_id = data.pjo_id
  if (data.document_url !== undefined) updateData.document_url = data.document_url
  if (data.notes !== undefined) updateData.notes = data.notes

  // Recalculate total if amounts changed
  if (data.subtotal !== undefined || data.tax_amount !== undefined) {
    const { data: invoice } = await supabase
      .from('vendor_invoices')
      .select('subtotal, tax_amount')
      .eq('id', id)
      .single()

    const newSubtotal = data.subtotal ?? invoice?.subtotal ?? 0
    const newTaxAmount = data.tax_amount ?? invoice?.tax_amount ?? 0

    updateData.subtotal = newSubtotal
    updateData.tax_amount = newTaxAmount
    updateData.total_amount = newSubtotal + newTaxAmount
  }

  // Handle BKK linking changes
  if (data.bkk_id !== undefined && data.bkk_id !== currentInvoice.bkk_id) {
    // Unlink old BKK
    if (currentInvoice.bkk_id) {
      await supabase
        .from('bukti_kas_keluar')
        .update({ vendor_invoice_id: null })
        .eq('id', currentInvoice.bkk_id)
    }

    // Link new BKK
    if (data.bkk_id) {
      await supabase
        .from('bukti_kas_keluar')
        .update({ vendor_invoice_id: id })
        .eq('id', data.bkk_id)
    }

    updateData.bkk_id = data.bkk_id
  }

  // Update invoice
  const { error: updateError } = await supabase
    .from('vendor_invoices')
    .update(updateData)
    .eq('id', id)

  if (updateError) {
    return { error: updateError.message }
  }

  revalidatePath('/finance/vendor-invoices')
  revalidatePath(`/finance/vendor-invoices/${id}`)

  return {}
}

/**
 * Delete a vendor invoice (only if status is 'received')
 */
export async function deleteVendorInvoice(id: string): Promise<{ error?: string }> {
  const supabase = await createClient()

  // Get current user
  const profile = await getCurrentUserProfile()
  if (!profile) {
    return { error: 'User not authenticated' }
  }

  // Check permission
  if (!canDeleteVendorInvoices(profile.role)) {
    return { error: 'You do not have permission to delete vendor invoices' }
  }

  // Get current invoice
  const { data: invoice, error: fetchError } = await supabase
    .from('vendor_invoices')
    .select('status, bkk_id')
    .eq('id', id)
    .single()

  if (fetchError || !invoice) {
    return { error: 'Vendor invoice not found' }
  }

  // Can only delete invoices in 'received' status
  if (invoice.status !== 'received') {
    return { error: 'Can only delete invoices in received status' }
  }

  // Unlink BKK if linked
  if (invoice.bkk_id) {
    await supabase
      .from('bukti_kas_keluar')
      .update({ vendor_invoice_id: null })
      .eq('id', invoice.bkk_id)
  }

  // Delete invoice
  const { error: deleteError } = await supabase
    .from('vendor_invoices')
    .delete()
    .eq('id', id)

  if (deleteError) {
    return { error: deleteError.message }
  }

  revalidatePath('/finance/vendor-invoices')

  return {}
}


/**
 * Get vendor invoices with filters
 */
export async function getVendorInvoices(
  filters?: Partial<VendorInvoiceFilterState>
): Promise<VendorInvoiceWithRelations[]> {
  const supabase = await createClient()

  // Get current user
  const profile = await getCurrentUserProfile()
  if (!profile) {
    return []
  }

  // Check permission
  if (!canViewVendorInvoices(profile.role)) {
    return []
  }

  let query = supabase
    .from('vendor_invoices')
    .select(`
      *,
      vendor:vendors (
        id,
        vendor_name,
        vendor_code,
        bank_name,
        bank_account,
        tax_id
      ),
      job_order:job_orders (
        id,
        jo_number
      ),
      pjo:proforma_job_orders (
        id,
        pjo_number
      ),
      bkk:bukti_kas_keluar (
        id,
        bkk_number,
        amount_spent,
        amount_requested
      ),
      verifier:user_profiles!vendor_invoices_verified_by_fkey (
        id,
        full_name
      ),
      approver:user_profiles!vendor_invoices_approved_by_fkey (
        id,
        full_name
      ),
      creator:user_profiles!vendor_invoices_created_by_fkey (
        id,
        full_name
      )
    `)
    .order('due_date', { ascending: true, nullsFirst: false })

  // Apply filters
  if (filters?.status && filters.status !== 'all') {
    query = query.eq('status', filters.status)
  }

  if (filters?.vendorId && filters.vendorId !== 'all') {
    query = query.eq('vendor_id', filters.vendorId)
  }

  if (filters?.joId && filters.joId !== 'all') {
    query = query.eq('jo_id', filters.joId)
  }

  if (filters?.pjoId && filters.pjoId !== 'all') {
    query = query.eq('pjo_id', filters.pjoId)
  }

  if (filters?.dateFrom) {
    query = query.gte('invoice_date', filters.dateFrom)
  }

  if (filters?.dateTo) {
    query = query.lte('invoice_date', filters.dateTo)
  }

  if (filters?.search) {
    const searchTerm = `%${sanitizeSearchInput(filters.search)}%`
    query = query.or(`invoice_number.ilike.${searchTerm},internal_ref.ilike.${searchTerm},description.ilike.${searchTerm}`)
  }

  const { data, error } = await query

  if (error) {
    return []
  }

  // Filter by aging bucket if specified (done in memory since it's calculated)
  let results = data as VendorInvoiceWithRelations[]

  if (filters?.agingBucket && filters.agingBucket !== 'all') {
    results = results.filter(invoice => {
      if (invoice.status === 'paid' || invoice.status === 'cancelled') {
        return filters.agingBucket === 'current'
      }
      return calculateAgingBucket(invoice.due_date) === filters.agingBucket
    })
  }

  return results
}

/**
 * Get a single vendor invoice by ID
 */
export async function getVendorInvoiceById(
  id: string
): Promise<VendorInvoiceWithRelations | null> {
  const supabase = await createClient()

  // Get current user
  const profile = await getCurrentUserProfile()
  if (!profile) {
    return null
  }

  // Check permission
  if (!canViewVendorInvoices(profile.role)) {
    return null
  }

  const { data, error } = await supabase
    .from('vendor_invoices')
    .select(`
      *,
      vendor:vendors (
        id,
        vendor_name,
        vendor_code,
        bank_name,
        bank_account,
        tax_id
      ),
      job_order:job_orders (
        id,
        jo_number
      ),
      pjo:proforma_job_orders (
        id,
        pjo_number
      ),
      bkk:bukti_kas_keluar (
        id,
        bkk_number,
        amount_spent,
        amount_requested
      ),
      verifier:user_profiles!vendor_invoices_verified_by_fkey (
        id,
        full_name
      ),
      approver:user_profiles!vendor_invoices_approved_by_fkey (
        id,
        full_name
      ),
      creator:user_profiles!vendor_invoices_created_by_fkey (
        id,
        full_name
      )
    `)
    .eq('id', id)
    .single()

  if (error) {
    return null
  }

  return data as VendorInvoiceWithRelations
}

/**
 * Get matching BKKs for a vendor and JO/PJO
 */
export async function getMatchingBKKs(
  vendorId: string,
  joId?: string,
  pjoId?: string
): Promise<{ id: string; bkk_number: string; amount_spent: number | null; amount_requested: number; purpose: string }[]> {
  const supabase = await createClient()

  let query = supabase
    .from('bukti_kas_keluar')
    .select('id, bkk_number, amount_spent, amount_requested, purpose')
    .eq('vendor_id', vendorId)
    .in('status', ['released', 'settled'])
    .is('vendor_invoice_id', null) // Only unlinked BKKs

  if (joId) {
    query = query.eq('jo_id', joId)
  }

  const { data, error } = await query.order('created_at', { ascending: false })

  if (error) {
    return []
  }

  return data || []
}

/**
 * Get vendors for dropdown (active vendors only)
 */
export async function getVendorsForDropdown(): Promise<{ id: string; vendor_name: string; vendor_code: string }[]> {
  const supabase = await createClient()

  const { data, error } = await supabase
    .from('vendors')
    .select('id, vendor_name, vendor_code')
    .eq('is_active', true)
    .order('vendor_name')

  if (error) {
    return []
  }

  return data || []
}

/**
 * Get job orders for dropdown
 */
export async function getJobOrdersForDropdown(): Promise<{ id: string; jo_number: string; description: string | null }[]> {
  const supabase = await createClient()

  const { data, error } = await supabase
    .from('job_orders')
    .select('id, jo_number, description')
    .in('status', ['active', 'completed', 'invoiced'])
    .order('created_at', { ascending: false })
    .limit(100)

  if (error) {
    return []
  }

  return data || []
}

/**
 * Get PJOs for dropdown
 */
export async function getPJOsForDropdown(): Promise<{ id: string; pjo_number: string; description: string | null }[]> {
  const supabase = await createClient()

  const { data, error } = await supabase
    .from('proforma_job_orders')
    .select('id, pjo_number, description')
    .eq('status', 'approved')
    .order('created_at', { ascending: false })
    .limit(100)

  if (error) {
    return []
  }

  return data || []
}


// =====================================================
// Verification and Approval Actions
// =====================================================

/**
 * Verify vendor invoice (3-way match with BKK)
 */
export async function verifyVendorInvoice(
  id: string,
  notes?: string
): Promise<{ result?: VerificationResult; error?: string }> {
  const supabase = await createClient()

  // Get current user
  const profile = await getCurrentUserProfile()
  if (!profile) {
    return { error: 'User not authenticated' }
  }

  // Check permission
  if (!canEditVendorInvoices(profile.role)) {
    return { error: 'You do not have permission to verify vendor invoices' }
  }

  // Get invoice with BKK
  const { data: invoice, error: fetchError } = await supabase
    .from('vendor_invoices')
    .select(`
      id, status, total_amount, bkk_id,
      bkk:bukti_kas_keluar (id, amount_spent, amount_requested)
    `)
    .eq('id', id)
    .single()

  if (fetchError || !invoice) {
    return { error: 'Vendor invoice not found' }
  }

  // Must be in 'received' status to verify
  if (invoice.status !== 'received') {
    return { error: 'Can only verify invoices in received status' }
  }

  // Must have linked BKK for 3-way match
  if (!invoice.bkk_id || !invoice.bkk) {
    return { error: 'Cannot verify invoice without linked BKK' }
  }

  // Calculate variance
  const bkkAmount = invoice.bkk.amount_spent ?? invoice.bkk.amount_requested
  const varianceResult = calculateVariance(bkkAmount, invoice.total_amount)

  // Determine new status based on variance
  const newStatus = varianceResult.withinTolerance ? 'verified' : 'disputed'

  // Update invoice
  const { error: updateError } = await supabase
    .from('vendor_invoices')
    .update({
      status: newStatus,
      verified_at: new Date().toISOString(),
      verified_by: profile.id,
      verification_notes: notes || null,
      updated_at: new Date().toISOString(),
    })
    .eq('id', id)

  if (updateError) {
    return { error: updateError.message }
  }

  revalidatePath('/finance/vendor-invoices')
  revalidatePath(`/finance/vendor-invoices/${id}`)

  return {
    result: {
      matched: varianceResult.withinTolerance,
      bkkAmount,
      invoiceAmount: invoice.total_amount,
      variance: varianceResult.variance,
      variancePercent: varianceResult.variancePercent,
    },
  }
}


/**
 * Approve vendor invoice for payment
 */
export async function approveVendorInvoice(
  id: string
): Promise<{ error?: string }> {
  const supabase = await createClient()

  // Get current user
  const profile = await getCurrentUserProfile()
  if (!profile) {
    return { error: 'User not authenticated' }
  }

  // Check permission
  if (!canApproveVendorInvoices(profile.role)) {
    return { error: 'You do not have permission to approve vendor invoices' }
  }

  // Get current invoice
  const { data: invoice, error: fetchError } = await supabase
    .from('vendor_invoices')
    .select('status')
    .eq('id', id)
    .single()

  if (fetchError || !invoice) {
    return { error: 'Vendor invoice not found' }
  }

  // Can only approve from 'verified' status
  if (invoice.status !== 'verified') {
    return { error: 'Cannot approve invoice that is not verified' }
  }

  // Update invoice
  const { error: updateError } = await supabase
    .from('vendor_invoices')
    .update({
      status: 'approved',
      approved_at: new Date().toISOString(),
      approved_by: profile.id,
      updated_at: new Date().toISOString(),
    })
    .eq('id', id)

  if (updateError) {
    return { error: updateError.message }
  }

  revalidatePath('/finance/vendor-invoices')
  revalidatePath(`/finance/vendor-invoices/${id}`)

  return {}
}

/**
 * Flag vendor invoice as disputed
 */
export async function disputeVendorInvoice(
  id: string,
  reason: string
): Promise<{ error?: string }> {
  const supabase = await createClient()

  // Get current user
  const profile = await getCurrentUserProfile()
  if (!profile) {
    return { error: 'User not authenticated' }
  }

  // Check permission
  if (!canEditVendorInvoices(profile.role)) {
    return { error: 'You do not have permission to dispute vendor invoices' }
  }

  if (!reason || reason.trim().length === 0) {
    return { error: 'Dispute reason is required' }
  }

  // Get current invoice
  const { data: invoice, error: fetchError } = await supabase
    .from('vendor_invoices')
    .select('status')
    .eq('id', id)
    .single()

  if (fetchError || !invoice) {
    return { error: 'Vendor invoice not found' }
  }

  // Can dispute from 'received' or 'verified' status
  if (!invoice.status || !['received', 'verified'].includes(invoice.status)) {
    return { error: 'Cannot dispute invoice in current status' }
  }

  // Update invoice
  const { error: updateError } = await supabase
    .from('vendor_invoices')
    .update({
      status: 'disputed',
      verification_notes: reason,
      verified_at: new Date().toISOString(),
      verified_by: profile.id,
      updated_at: new Date().toISOString(),
    })
    .eq('id', id)

  if (updateError) {
    return { error: updateError.message }
  }

  revalidatePath('/finance/vendor-invoices')
  revalidatePath(`/finance/vendor-invoices/${id}`)

  return {}
}
